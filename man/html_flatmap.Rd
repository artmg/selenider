% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatmap.R
\name{html_flatmap}
\alias{html_flatmap}
\alias{as.list.selenider_elements}
\alias{element_list}
\title{Iterate over an element collection}
\usage{
html_flatmap(x, .f, ...)

\method{as.list}{selenider_elements}(x, timeout = NULL, ...)

element_list(x, timeout = NULL)
}
\arguments{
\item{x}{A \code{selenider_elements} object.}

\item{.f}{A function to apply to each element of \code{x}.}

\item{...}{Passed into \code{.f}.}

\item{timeout}{How long to wait for \code{x} to exist while computing its length.}
}
\value{
\code{html_flatmap()} returns a \code{selenider_element} object.
\code{as.list()}/\code{element_list()} returns a list of \code{selenider_element} objects.
}
\description{
Use \code{html_flatmap()} when you want to select further sub-elements
\emph{for each} element of a collection.

\code{html_flatmap()} allows you to apply a function to each element of
a \code{selenider_elements} object, provided that the function returns a
\code{selenider_element}/\code{selenider_elements} object itself. The result will
then be flattened into a single \code{selenider_elements} object. The benefit
of this over traditional iteration techniques is that the laziness of the
elements will be maintained, and nothing will be fetched from the DOM.

\code{as.list()} transforms a \code{selenider_elements} object into a list of
\code{selenider_element} objects. The result can then be used in for loops and
higher order functions like \code{\link[=lapply]{lapply()}}/\code{\link[purrr:map]{purrr::map()}} (whereas a \code{selenider_element}
object cannot)

\code{element_list()} is the underlying function called by \code{element_list()}.

\code{html_flatmap()} works by executing \code{.f} on a mock element, then recording the
results in \code{x}. This means that no matter the length of \code{x}, \code{.f} is only evaluated
once, and during the \code{html_flatmap()} call. For this reason, \code{.f} should not invoke
any side effects or do anything other than selecting sub-elements.

\code{as.list()}/\code{element_list()} essentially turns \code{x} into:
\code{list(x[[1]], x[[2]], ...)}
However, to do this, the length of \code{x} must be computed. This means that while
each element inside the list is still lazy, the list itself cannot be considered
lazy, since the number of elements in the DOM may change. To avoid problems, it is
recommended to use an element list just after it is created, to make sure the
list is an accurate representation of the DOM when it is being used.
}
\examples{
\dontshow{if (selenider_available(online = FALSE)) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
html <- "
<div id='div1'>
  <p>Text 1</p>
</div>
<div id='div2'>
  <p>Text 2</p>
</div>
<div id='div3'>
  <p>Text 3</p>
</div>
<div id='div4'>
  <p>Text 4</p>
</div>
"

session <- minimal_selenider_session(html)

divs <- ss("div")

# Get the <p> tag inside each div.
divs |>
  html_flatmap(\(x) x |> html_element("p"))

# Or:
p_tags <- divs |>
  html_flatmap(html_element, "p")

# To get the text in each tag, we can't use html_flatmap()
for (elem in as.list(p_tags)) {
  print(html_text(elem))
}

# Or:
lapply(as.list(p_tags), html_text)

\dontshow{
# Clean up all connections and invalidate default chromote object
selenider_cleanup()
}
\dontshow{\}) # examplesIf}
}
