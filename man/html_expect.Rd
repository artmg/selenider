% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expect.R, R/wait_until.R
\name{html_expect}
\alias{html_expect}
\alias{html_wait_until}
\title{Test one or more conditions on HTML elements}
\usage{
html_expect(x, ..., timeout = NULL)

html_wait_until(x, ..., timeout = NULL)
}
\arguments{
\item{x}{A \code{selenider_element}/\code{selenider_elements} object, or a condition.}

\item{...}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> Function calls or functions
that must return a logical value. If multiple conditions are given, they
must all be \code{TRUE} for the test to pass.}

\item{timeout}{The number of seconds to wait for a condition to pass. If not
specified, the timeout used for \code{x} will be used, or the timeout of the
local session if an element is not given.}
}
\value{
\code{html_expect()} returns the element(s) \code{x}, or \code{NULL} if an element or
collection of elements was not given in \code{x}.

\code{html_wait_for()} returns a boolean flag: TRUE if the test passes, FALSE
otherwise.
}
\description{
\code{html_expect()} waits for a set of conditions to return TRUE. If, after a
certain period of time (by default 4 seconds), this does not happen, an
informative error is thrown. Otherwise, the original element is returned.

\code{html_wait_until()} does the same, but returns a logical value (whether or
not the test passed), allowing you to handle the failure case explicitly.
}
\section{Conditions}{
Conditions can be supplied as functions or calls.

Functions allow you to use unary conditions without formatting them as a
call (e.g. \code{is_present} rather than \code{is_present()}). It also allows you to make
use of R's \link[base:function]{anonymous function syntax} to quickly create
custom conditions. \code{x} will be used as the first argument of this function.

Function calls allow you to use conditions that take multiple arguments (e.g.
\code{has_text()}) without the use of an intermediate function. The call will
be modified so that \code{x} is the first argument to the function call. For
example, \code{has_text("a")} will be modified to become: \code{has_text(x, "a")}.

The and (\code{&&}), or (\code{||}) and not (\code{!}) functions can be used on both types
of conditions. If more than one condition are given in \code{...}, they are
combined using \code{&&}.
}

\section{Custom conditions}{
Any function which takes a selenider element or element collection as its
first argument, and returns a logical value, can be used as a condition.

Additionally, these functions provide a few features that make creating
custom conditions easy:
\itemize{
\item Errors with class \code{selenider_element_absent_element} are handled, and
the function is prevented from terminating early. This means that if
an element is not found, the function will retry instead of immediately
throwing an error.
\item \code{selenider} functions used inside conditions have their timeout, by
default, set to 0, ignoring the local timeout. This is important, since
\code{html_expect()} and \code{html_wait_until()} implement a retry mechanic
manually. To override this default, manually specify a timeout.
}

These two features allow you to use functions like \code{\link[=html_text]{html_text()}} to access
properties of an element, without needing to worry about the errors that
they throw or the timeouts that they use. See Examples for an example of a
custom condition.

These custom conditions can also be used with \code{\link[=html_filter]{html_filter()}} and
\code{\link[=html_find]{html_find()}}.
}

\examples{
session <- mock_selenider_session()

s(".class1") |>
  html_expect(is_present)

s(".class1") |>
  html_expect(is_visible, is_enabled)

s(".class1") |>
  html_expect(is_visible || is_enabled)

s(".class2") |>
  html_expect(!is_present) |>
  try() # Since this condition will fail
# Or is_absent, etc.

# html_expect() returns the element, so can be used in chains
s(".button1") |>
  html_expect(is_visible) |>
  click()
# Note that click() will do this automatically

s(".text1") |>
  html_expect(has_exact_text("Example text"))

# Or use an anonymous function
s(".text1") |>
  html_expect(\(elem) identical(html_text(elem), "Example text"))

# If your conditions are not specific to an element, you can omit the `x` argument
elem_1 <- s(".class1")
elem_2 <- s(".class2")

html_expect(is_present(elem_1) || is_present(elem_2))

# We can now use the conditions on their own to figure out which element exists
if (is_present(elem_1)) {
  click(elem_1)
} else {
  click(elem_2)
}

# Use html_wait_for() to handle failures manually
elem <- s(".class2")
if (html_wait_until(elem, is_present)) {
  click(elem)
} else {
  reload()
}

# Creating a custom condition is easiest with an anonymous function
s(".text1") |>
  html_expect(
    \(elem) elem |>
      html_text() |>
      grepl(pattern = "Example .*")
  )

# Or create a function, to reuse the condition multiple times
text_contains <- function(x, pattern) {
  text <- html_text(x)
  
  grepl(pattern, text)
}

s(".text1") |>
  html_expect(text_contains("Example *"))

}
\seealso{
\itemize{
\item \code{\link{html-conditions}} for predicates for a single HTML element.
\item \code{\link{html-conditions-multiple}} for predicates for multiple HTML elements.
}
}
