% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expect.R, R/wait_until.R
\name{html_expect}
\alias{html_expect}
\alias{html_wait_until}
\title{Test one or more conditions on HTML elements}
\usage{
html_expect(x, ..., timeout = NULL)

html_wait_until(x, ..., timeout = NULL)
}
\arguments{
\item{x}{A \code{selenider_element}/\code{selenider_elements} object, or a condition.}

\item{...}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> Function calls or functions
that must return a logical value. If multiple conditions are given, they
must all be \code{TRUE} for the test to pass.}

\item{timeout}{The number of seconds to wait for a condition to pass. If not
specified, the timeout used for \code{x} will be used, or the timeout of the
local session if an element is not given.}
}
\value{
\code{html_expect()} returns the element(s) \code{x} when the test passes, or \code{NULL} if
an element or collection of elements was not given in \code{x}.

\code{html_wait_for()} returns a boolean flag: TRUE if the test passes, FALSE
otherwise.
}
\description{
\code{html_expect()} waits for a set of conditions to return TRUE. If, after a
certain period of time (by default 4 seconds), this does not happen, an
informative error is thrown. Otherwise, the original element is returned.

\code{html_wait_until()} does the same, but returns a logical value (whether or
not the test passed), allowing you to handle the failure case explicitly.
}
\section{Custom conditions}{
Any function which takes a selenider element or element collection as its
first argument, and returns a logical value, can be used as a condition.
}

\section{Conditions}{
Conditions can be supplied as functions or calls.

Functions allow you to use unary conditions without formatting them as a
call (e.g. \code{is_present} rather than \code{is_present()}). It also allows you to make
use of R's \link[base:function]{anonymous function syntax} to quickly create
custom conditions. \code{x} will be used as the first argument of this function.

Function calls allow you to use conditions that take multiple arguments (e.g.
\code{has_text()}) without the use of an intermediate function. The call will
be modified so that \code{x} is the first argument to the function call. For
example, \code{has_text("a")} will be modified to become: \code{has_text(x, "a")}.
}

\examples{
session <- mock_selenider_session()

s(".class1") |>
  html_expect(is_present)

s(".class1") |>
  html_expect(is_visible, is_enabled)

s(".class1") |>
  html_expect(is_visible || is_enabled)

s(".class2") |>
  html_expect(!is_present) |>
  try() # Since this condition will fail
# Or is_absent, etc.

# html_expect() returns the element, so can be used in chains
s(".button1") |>
  html_expect(is_visible) |>
  click()
# Note that click() will do this automatically

s(".text1") |>
  html_expect(has_exact_text("Example text"))

# Or use an anonymous function
s(".text1") |>
  html_expect(\(elem) identical(html_text(elem), "Example text"))

# This is useful for complex conditions:
s(".text1") |>
  html_expect(
    \(elem) elem |>
      html_text() |>
      grepl("Example .*", x = _)
  )

# If your conditions are not specific to an element, you can omit the `x` argument
elem_1 <- s(".class1")
elem_2 <- s(".class2")

html_expect(is_present(elem_1) || is_present(elem_2))

# We can now use the conditions on their own to figure out which element exists
if (is_present(elem_1)) {
  click(elem_1)
} else {
  click(elem_2)
}

# Use html_wait_for() to handle failures manually
elem <- s(".class2")
if (html_wait_until(elem, is_present)) {
  click(elem)
} else {
  reload()
}

}
\seealso{
\itemize{
\item \code{\link{html-conditions}} for predicates for a single HTML element.
\item \code{\link{html-conditions-multiple}} for predicates for multiple HTML elements.
}
}
